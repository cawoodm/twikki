{
  "tiddlers": [
    {
      "title": "$BackupPlugin",
      "text": "/**\n * ## Description\n * Backup your data to [JSONBIN.io](https://jsonbin.io)\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.1.0\n * }\n * ```\n */\n// ## Code\n// ```javascript\ntw.macros.backup = {\n  restoreButton() {\n    return tw.ui.button('{{$IconRestore}}', 'backup.restore', null, 'restore', 'title=\"Restore Backup Data\"');\n  },\n  backupButton() {\n    return tw.ui.button('{{$IconBackup}}', 'backup.save', null, 'backup', 'title=\"Backup Data\"');\n  },\n  async restore() {\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.backup?.JSONBin?.accessKey || !settings.backup?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.backup.JSONBin.binId, {\n      headers: {\n        'X-Access-Key': settings.backup.JSONBin.accessKey,\n      },\n    });\n    if (!res.ok) return tw.ui.notify(`Restore failed '${res.status}' (see log)`, 'E');\n    let result = await res.json();\n    Object.assign(tw.tiddlers, result.record);\n    tw.events.send('reboot.soft');\n    tw.ui.notify('Restore complete!', 'S'); // Should we save/remind to save?\n  },\n  async save() {\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.backup?.JSONBin?.accessKey || !settings.backup?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let body = JSON.stringify({\n      all: tw.tiddlers.all,\n      visible: tw.tiddlers.visible,\n      // trashed: tw.tiddlers.trashed,\n    });\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.backup.JSONBin.binId, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Access-Key': settings.backup.JSONBin.accessKey,\n      // 'X-Bin-Versioning': true, // Not available in Free JSONBin :-(\n      },\n      body,\n    });\n    // doesn't get caught by notify!! throw new Error('Backup failed: ' + res.statusText);\n    if (!res.ok) return tw.ui.notify(`Backup failed '${res.status}' (see log)`, 'E');\n    // let result = await res.json();\n    tw.ui.notify(`Backup complete! (${body.length / 1000} KB)`, 'S');\n  },\n};\ntw.events.subscribe('backup.save', tw.macros.backup.save);\ntw.events.subscribe('backup.restore', tw.macros.backup.restore);\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4761999Z",
      "updated": "2024-10-23T07:02:04.4368671Z"
    },
    {
      "title": "$ButtonsFunctions",
      "text": "/**\n  * Buttons to Show/Hide Tiddlers:\n  * Examples:\n  *  - Show all tiddlers\n  *    <<button Click Me!;ui.open.all>>\n  */\ntw.macros.button = (title, msg, payload = '', id = '') => {\n  return tw.ui.button(title, msg, payload, id);\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4771503Z",
      "updated": "2024-10-04T19:45:16.1906502Z"
    },
    {
      "title": "$CoreThemeManager",
      "text": "/**\n * ## Description\n * Provides all theme logic\n * Provides <<ThemeSelector>> widget\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.0.1\n * }\n * ```\n */\n(function(){\n\n  wireUp('ui.loaded', () => {\n    tw.theme = {\n      stylesheets: {\n        custom: new CSSStyleSheet(),\n      },\n      getThemeNames,\n    };\n    document.adoptedStyleSheets.push(tw.theme.stylesheets.custom);\n    themeUpdate();\n  });\n\n  wireUp('tiddler.updated', tiddlerChanged);\n  wireUp('tiddler.deleted', tiddlerChanged);\n  function tiddlerChanged(title) {\n    if (tiddlerIsThemeRelevant(title))\n      return themeUpdate();\n    if (tiddlerIsATheme(title))\n      return themesUpdate();\n  }\n\n  wireUp('theme.switch', themeSwitch);\n  function themeSwitch(theme) {\n    if (!theme) return;\n    if (!tw.call('tiddlerExists', theme)) return tw.ui.notify(`Unknown theme tiddler '${theme}'!`, 'E');\n    let tiddler = tw.run.getTiddler('$Theme');\n    tiddler.text = `[[${theme}]]`;\n    delete tiddler.doNotSave;\n    tw.run.updateTiddlerHard('$Theme', tiddler);\n    if (theme.match(/Dark/)) tw.core.dom.disableStyleSheet('highlight-light');\n    else tw.core.dom.disableStyleSheet('highlight-dark');\n    tw.events.send('tiddler.refresh', '$Theme');\n    themeUpdate(theme);\n    tw.events.send('save.silent');\n  }\n\n  wireUp('ui.reloaded', themeUpdate);\n  function themeUpdate() {\n    let css = getThemeStyleSheets().map(tw.run.getTiddlerTextRaw).join('\\n');\n    tw.theme.stylesheets.custom.replaceSync(css);\n  }\n\n  function tiddlerIsATheme(title) {\n    return tw.run.getTiddler(title)?.tags.includes('$Theme');\n  }\n\n  function themesUpdate() {\n    tw.events.send('tiddler.refresh', '$Themes');\n  }\n\n  function tiddlerIsThemeRelevant(title) {\n    let themeName = getCurrentThemeName();\n    return title === '$Theme' || title === themeName || getThemeStyleSheets().includes(title);\n  }\n  function getCurrentThemeName() {\n    return tw.run.getTiddlerTextRaw('$Theme').replace(/[\\[\\]]/g, ''); // Remove possible [[links]]\n  }\n  function getThemeNames() {\n    return tw.run.getTiddlersByTag('$Theme').map(t => t.title);\n  }\n  function getThemeStyleSheets() {\n    let theme = getCurrentThemeName();\n    if (!tw.call('tiddlerExists', theme)) {\n      tw.ui.notify('Unable to determine theme name from $Theme tiddler! Falling back on $CoreTheme', 'W');\n      theme = '$CoreTheme';\n    }\n    return tw.run.getTiddlerList(theme);\n  }\n\n  tw.macros.core.ThemeSelector = () => {\n    let theme = getCurrentThemeName();\n    return `<select id=\"theme-select\" onchange=\"tw.events.send('theme.switch', this.value);\">\n    ${getThemeNames().map(n => `<option value=\"${n}\"${n === theme ? ' selected' : ''}>${n.replace(/(^\\$)|(Theme$)/g, '')}</option>`).join('\\n')}\n  </select>`;\n  };\n\n  function wireUp(event, handler) {\n    tw.events.subscribe(event, handler, 'CoreThemeManager');\n  }\n})();\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4781791Z",
      "updated": "2024-11-08T19:39:24.2613785Z"
    },
    {
      "title": "$GeneralWidgets",
      "text": "// Send any message <<command ui.open.all pck:website>>\ntw.macros.core.command = (msg, payload = '') => {\n  return tw.ui.button(`Send: ${msg}:${payload}`, msg, payload, '', 'title=\"Send Command\"');\n};\n// Reload UI\ntw.macros.core.Reload = () => {\n  return tw.ui.button('🔄️', 'ui.reload', null, '', 'title=\"Reload\"');\n};\ntw.macros.core.Save = () => {\n  return tw.ui.button('{{$IconSave}}', 'save.all', null, '', 'title=\"Save\"');\n};\ntw.macros.core.Settings = () => {\n  return tw.ui.button('{{$IconSettings}}', 'tiddler.show', '$Settings', '', 'title=\"Settings\"');\n};\ntw.macros.core.New = () => {\n  return tw.ui.button('{{$IconNew}}', 'tiddler.new', null);\n};\n// Lists types used in all tiddlers\ntw.macros.core.AllTypesMacro = () => {\n  return tw.lib.markdown([...new Set(tw.tiddlers.all.map(t => `* [${t.type}](#msg:tiddlers.show:type:${t.type})\\n`))].join(''));\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4791785Z",
      "updated": "2024-10-26T10:53:54.6064493Z"
    },
    {
      "title": "$GithubSaverExtension",
      "text": "tw.plugins.GitHubSaver = {\n  async save({text, token, repo, path, filename, commitMessage, branch, endpoint}) {\n    //\n    branch = branch || 'main';\n    endpoint = endpoint || 'https://api.github.com';\n    commitMessage = 'TWikki Save ' + new Date().toISOString();\n\n    validate({text, token, repo, path, filename, commitMessage});\n\n    const headers = {\n      'Accept': 'application/vnd.github.v3+json',\n      'Content-Type': 'application/json;charset=UTF-8',\n      // 'Authorization': 'Basic ' + btoa(username + ':' + password),\n      'Authorization': 'Bearer ' + token,\n      'If-None-Match': '',\n    };\n\n    // Normalize path with trailing slash\n    if (path.substring(0, 1) !== '/') path = '/' + path;\n    if (path.substring(path.length - 1) !== '/') path = path + '/';\n\n    // List Files\n    const listUrl = endpoint + '/repos/' + repo + '/contents' + path;\n    let res = await fetch(listUrl, {\n      method: 'GET',\n      headers: headers,\n      data: {\n        ref: branch,\n      },\n    });\n\n    if (res.ok) throw new Error(`GitHubSaver.save() GET files failed ${res.status} for ${listUrl}`);\n\n    // Find the sha of the file if it exists\n    const files = await res.json();\n    const sha = files.find(file => file.name === filename);\n\n    const data = {\n      message: commitMessage,\n      content: btoa(text),\n      branch: branch,\n      sha: sha,\n    };\n\n    // Perform a PUT request to save the file\n    let putUrl = listUrl + filename;\n    res = await fetch(putUrl, {\n      method: 'PUT',\n      headers: headers,\n      data: JSON.stringify(data),\n    });\n    if (res.ok) throw new Error(`GitHubSaver.save() PUT file failed ${res.status} for ${putUrl}`);\n\n    function validate(obj) {\n      Object.keys.forEach(k => {\n        if (!obj[k]) throw new Error(`GitHubSaver.save() missing parameter '${k}'!`);\n      });\n    }\n\n  },\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4801790Z",
      "updated": "2024-11-08T11:51:50.6934482Z"
    },
    {
      "title": "$IncludeFunctions",
      "text": "/* eslint-disable no-eval */\n// Include the contents of another tiddler\n// <<include $TWikkiVersion>>\ntw.macros.include = (title) => {\n  // dp('include', title);\n  return tw.call('renderTiddler', title);\n};\ntw.macros.eval = (code) => {\n  return eval(code);\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4811778Z",
      "updated": "2024-11-08T11:51:50.8318222Z"
    },
    {
      "title": "$ListTiddlersWidgets",
      "text": "Object.assign(tw.macros.core, {\n  // List all tiddlers as a bulleted list\n  list({tag, title, pck, type} = {}) {\n    if (!title) title = '!^\\\\$'; // Hide system tiddlers by default\n    return tw.run.showTiddlerList(\n      tw.tiddlers.all\n        .filter(tw.util.titleMatch(title))\n        .filter(t => !pck || t.package === pck)\n        .filter(t => !type || t.type === type)\n        .filter(tw.util.tagMatch(tag)),\n    );\n  },\n  text (title) {\n    return tw.run.getTiddlerTextRaw(title);\n  },\n  Section ({name, content, message, payload, attr}) {\n    if (message) content = tw.events.send(message, payload)?.[0];\n    return tw.ui.section({name, content, attr});\n  },\n  Expand ({name, content, message, payload, attr}) {\n    if (message) content = tw.events.send(message, payload)?.[0];\n    return tw.ui.expand({name, content, attr});\n  },\n  Expose ({name, content, message, payload, attr}) {\n    return tw.ui.expose({name, content, message, payload, attr});\n  },\n  // List all tiddlers on a single line with comma separation\n  AllTiddlersSimple (sep) {\n    return tw.lib.markdown(tw.tiddlers.all.map(t => t.title).join(sep || ', '));\n  },\n  // List all tags\n  AllTagsSimple (sep) {\n    if (!sep) sep = ', ';\n    let allTags = tw.macros.core.allTags();\n    return allTags.join(sep);\n  },\n  allTags () {\n    let tags = [];\n    tw.tiddlers.all.forEach(t => {\n      t.tags.filter(t => !!t).forEach(tag => {\n        tags.push(tag);\n      });\n    });\n    return [...new Set(tags)];\n  },\n  AllTagsLinked (sep) {\n    if (!sep) sep = ', ';\n    let allTags = tw.macros.core.allTags();\n    return tw.lib.markdown(\n      allTags.map(t => (`[${t}](#msg:ui.open.all:{\"tag\":\"${t}\",\"title\":\"*\"})`)).join(sep),\n    );\n  },\n});\n\ntw.events.subscribe('tiddlers.list', tw.macros.core.list);\ntw.events.subscribe('tiddler.text', tw.macros.core.text);\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4821792Z",
      "updated": "2024-10-26T08:46:06.4596127Z"
    },
    {
      "title": "$PackageWidgets",
      "text": "tw.macros.packages = {\n  // Example: Import package website without overwriting\n  // <<packages.import name:website url:./packages/website.json filter:* force:false>>\n  import({name, url, filter, overWrite, doNotSave}) {\n    if (!name) throw new Error('ERROR: No name supplied to packages.import macro!');\n    if (!url) throw new Error('ERROR: No url supplied to packages.import macro!');\n    return tw.ui.button(`Import: ${name} ${filter ? ' (' + filter + ')' : ''}`, 'package.reload.url', {url, name, overWrite, doNotSave});\n  },\n  importBin({name, url, filter, overWrite, doNotSave}) {\n    if (!name) throw new Error('ERROR: No name supplied to packages.importBin macro!');\n    if (!url) throw new Error('ERROR: No url supplied to packages.importBin macro!');\n    return tw.ui.button(`Import: ${name} ${filter ? ' (' + filter + ')' : ''}`, 'package.reload.bin', {url, name, overWrite, doNotSave});\n  },\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4841787Z",
      "updated": "2024-10-19T09:44:42.0935910Z"
    },
    {
      "title": "$ShowTiddlersWidgets",
      "text": "/**\n  * Buttons to Show/Hide Tiddlers:\n  * Examples:\n  *  - Show all tiddlers tagged with Foo\n  *    <<ShowAllTiddlersButton tag:Foo>>\n  * -  Show all tiddlers not tagged with $Shadow\n  *    <<ShowAllTiddlersButton tag:!$Shadow>>\n  * - Show all tiddlers not tagged with $Shadow with title containing 'oo'\n  *    <<ShowAllTiddlersButton !$Shadow title:oo>>\n  * -  Show all tiddlers with title beginning with A\n  *   <<ShowAllTiddlersButton tag:*, title:^A>>\n  */\ntw.macros.core.ShowAllTiddlersButton = ({tag = '', title = ''} = {}) => {\n  return tw.ui.button('{{$IconOpenAll}}', 'ui.open.all', {tag, title}, 'open-all', 'title=\"Open All Tiddlers\"');\n};\n// Show all tiddlers with text (but really all)\ntw.macros.core.CloseAllTiddlersButton = ({tag = '*', title = '*'} = {}) => {\n  return tw.ui.button('{{$IconCloseAll}}', 'ui.close.all', {tag, title}, 'close-all', 'title=\"Close All Tiddlers\"');\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4851795Z",
      "updated": "2024-11-08T19:58:56.9762192Z"
    },
    {
      "title": "$SynchDataPlugin",
      "text": "/**\n * ## Description\n * $SynchDataFunctions\n * Synch your data with [JSONBIN.io](https://jsonbin.io)\n * ### Release Notes\n * * v1.0.8\n *   * Don't synch trashed tiddlers\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.0.7\n * }\n * ```\n */\n// ## Code\n// ```javascript\n// TODO: Push force, clearing remote\n// TODO: Pull force, clearing local\n// TODO: Selective Synch: Include/Exclude Tags/Packages\ntw.macros.synch = (function(){\n  // TODO: Make events handler support asynch\n  // tw.events.subscribe('synch.full')\n  // onclick=tw.events.send(\\'synch.full\\')\n  return {\n    // <<synch.full>>: Push/pull to/from remote\n    full() {\n      return tw.ui.button('{{$IconSynch}}', 'synch.full', null, 'btn-synch', 'title=\"Synch Data\"');\n    },\n    async doFull() {\n      return await synch({pull: true, push: true});\n    },\n    // <<synch.test>>: Simulate push/pull to/from remote\n    test() {\n      return '<button onclick=\"tw.macros.synch.doTest()\">Synch Test</button>';\n    },\n    async doTest() {\n      return await synch({pull: true, push: true, dryRun: true});\n    },\n    // <<synch.pull>>: Only import from remote\n    pull() {\n      return tw.ui.button('{{$IconPull}}', 'synch.pull', null, 'btn-synch-pull', 'title=\"Pull Synched Data\"');\n    },\n    async doPull() {\n      return await synch({pull: true, push: false});\n    },\n    // <<synch.push>>: Only write to remote\n    push() {\n      return tw.ui.button('{{$IconPush}}', 'synch.push', null, 'btn-synch-push', 'title=\"Push Synched Data\"');\n    },\n    async doPush() {\n      return await synch({pull: false, push: true});\n    },\n    // TODO: Delete all remote and push (backup)\n    // TODO: Delete all local and pull (restore)\n  };\n\n  // eslint-disable-next-line complexity\n  async function synch({push = true, pull = true, dryRun = false}) {\n\n    if (!push && !pull) throw new Error('SynchDataFunctions: Please supply push or pull parameters!');\n\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.synch?.JSONBin?.accessKey || !settings.synch?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let headers = {'X-Access-Key': settings.synch.JSONBin.accessKey};\n\n    // Fetch remote\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.synch.JSONBin.binId, {headers});\n    if (!res.ok) return tw.ui.notify(`Restore failed '${res.status}' (see log)`, 'E');\n    let result = await res.json();\n    let remoteTiddlers = result.record.tiddlers || [];\n    let remoteTrashedTiddlers = result.record.trashed || [];\n\n    let log = [];\n    let remote = {create: [], update: [], delete: []};\n    let local = {create: [], update: [], delete: []};\n\n    let localTiddlers = tw.tiddlers.all\n      .filter(t => !t.isRawShadow); // Don't synch raw shadows - See BUG below\n\n    // eslint-disable-next-line complexity\n    remoteTiddlers.forEach(remoteTiddler => {\n      remoteTiddler.created = new Date(remoteTiddler.created);\n      remoteTiddler.updated = new Date(remoteTiddler.updated);\n      let localTiddler = localTiddlers.find(t => t.title === remoteTiddler.title);\n      if (remoteTiddler.tags.includes('$NoSynch') || localTiddler?.tags.includes('$NoSynch')) log.push(`Skipping $NoSynch tiddler [[${localTiddler.title}]]`);\n      // if (remoteTiddler.title.match(/SynchLog/)) debugger;\n      // TODO: BUG: Deleted local shadow tiddler is pulled in from remote\n      let deletedLocalTiddler = tw.tiddlers.trashed.find(t => t.title === remoteTiddler.title);\n      let deletedLocally = !localTiddler && deletedLocalTiddler?.updated > remoteTiddler.updated;\n      let createdRemotely = !localTiddler && !deletedLocally;\n      let updatedLocally = localTiddler?.updated > remoteTiddler.updated;\n      let updatedRemotely = remoteTiddler.updated > localTiddler?.updated;\n      if (deletedLocally) {\n        // Delete Remote\n        if (push) remote.delete.push(deletedLocalTiddler.title);\n      } else if (createdRemotely) {\n        // Restore Local: Updated remotely after local delete\n        if (pull) {\n          if (!dryRun) tw.run.addTiddler(remoteTiddler);\n          local.create.push(remoteTiddler.title);\n          log.push(`Created local tiddler [[${remoteTiddler.title}]]`);\n        }\n      } else if (updatedLocally) {\n        // Local update is newer\n        if (push) remote.update.push(localTiddler.title); // 👈\n      } else if (updatedRemotely) {\n        // Remote update is newer\n        if (push) {\n          if (!dryRun) tw.run.updateTiddlerHard(remoteTiddler.title, remoteTiddler);\n          local.update.push(remoteTiddler.title);\n          log.push(`Updated local tiddler [[${localTiddler.title}]]`); // 👈\n        }\n      }\n    });\n\n    localTiddlers.forEach(localTiddler => {\n      if (localTiddler.tags.includes('$NoSynch')) log.push(`Skipping $NoSynch tiddler [[${localTiddler.title}]]`);\n      let remoteTiddler = remoteTiddlers.find(t => t.title === localTiddler.title);\n      if (remoteTiddler) {\n        remoteTiddler.created = new Date(remoteTiddler.created);\n        remoteTiddler.updated = new Date(remoteTiddler.updated);\n      }\n      let deletedRemoteTiddler = remoteTrashedTiddlers.find(t => t.title === localTiddler.title);\n      let deletedRemotely = !remoteTiddler && deletedRemoteTiddler?.updated > localTiddler.updated;\n      let createdLocally = !remoteTiddler && !deletedRemotely;\n      if (deletedRemotely) {\n        // Delete Locally\n        if (pull) {\n          if (!dryRun) tw.run.deleteTiddler(localTiddler.title, true);\n          local.delete.push(remoteTiddler.title);\n          log.push(`Deleted local tiddler [[${localTiddler.title}]]`);\n        }\n      } else if (createdLocally) {\n        if (push) remote.create.push(localTiddler.title);\n      }\n      // Updated locally/remotely handled above ☝️\n    });\n\n    if (remote.create.length + remote.update.length + remote.delete.length +\n      local.create.length + local.update.length + local.delete.length === 0\n    ) return tw.ui.notify('No changes to synch', 'S');\n\n    if (push) {\n      // Perform remote updates\n      remote.create.forEach(title => {\n        log.push(`Created remote tiddler [[${title}]]`);\n      });\n      remote.update.forEach(title => {\n        log.push(`Updated remote tiddler [[${title}]]`);\n      });\n      remote.delete.forEach(title => {\n        log.push(`Deleted remote tiddler [[${title}]]`);\n      });\n    }\n\n    let logTiddler = {\n      title: `$SynchLog ${new Date().toISOString()}`,\n      text: logSummary(local, remote) + '\\n\\n## Log\\n' + log.join('  \\n') + '',\n      tags: ['$SynchLog'],\n      type: 'x-twikki',\n    };\n\n    if (push && !dryRun) {\n      let body = JSON.stringify({\n        tiddlers: localTiddlers,\n        visible: tw.tiddlers.visible,\n      });\n      // We never push/pull trashed as this is local information (we read but never write it)\n      res = await fetch('https://api.jsonbin.io/v3/b/' + settings.synch.JSONBin.binId, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Access-Key': settings.synch.JSONBin.accessKey,\n        },\n        body,\n      });\n      // doesn't get caught by notify!! throw new Error('Backup failed: ' + res.statusText);\n      if (!res.ok) return tw.ui.notify(`Synch (push) to remote failed '${res.status}' (see log)`, 'E');\n    }\n\n    if (!dryRun) tw.events.send('reboot.softer');\n\n    if (push && pull) {\n      tw.ui.notify('Synch (full) complete!', 'S');\n    } else if (pull) {\n      tw.ui.notify('Synch (pull) complete!', 'S');\n    } else if (push) {\n      tw.ui.notify('Synch (push) complete!', 'S');\n    }\n\n    tw.run.previewTiddler(logTiddler);\n\n    function logSummary(local, remote) {\n      return `\n## Local\n* Created (${local.create.length}) ${local.create.length ? ':\\n  * [[' + local.create.join(']]\\n  * [[') + ']]\\n' : ''}\n* Updated (${local.update.length}) ${local.update.length ? ':\\n  * [[' + local.update.join(']]\\n  * [[') + ']]\\n' : ''}\n* Deleted (${local.delete.length}) ${local.delete.length ? ':\\n  * [[' + local.delete.join(']]\\n  * [[') + ']]\\n' : ''}\n## Remote\n* Created (${remote.create.length}) ${remote.create.length ? ':\\n  * [[' + remote.create.join(']]\\n  * [[') + ']]\\n' : ''}\n* Updated (${remote.update.length}) ${remote.update.length ? ':\\n  * [[' + remote.update.join(']]\\n  * [[') + ']]\\n' : ''}\n* Deleted (${remote.delete.length}) ${remote.delete.length ? ':\\n  * [[' + remote.delete.join(']]\\n  * [[') + ']]\\n' : ''}\n`.trim();\n    }\n  }\n\n})();\ntw.events.subscribe('synch.full', 'tw.macros.synch.doFull');\ntw.events.subscribe('synch.push', 'tw.macros.synch.doPush');\ntw.events.subscribe('synch.pull', 'tw.macros.synch.doPull');\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4861791Z",
      "updated": "2024-11-08T11:50:59.4915046Z"
    },
    {
      "title": "$TiddlerSearchResult",
      "text": "* {{!!title}} ",
      "tags": [],
      "type": "x-twikki",
      "created": "2024-11-08T10:20:43.4871774Z",
      "updated": "2024-10-04T19:45:16.1926481Z"
    },
    {
      "title": "$TrashedTiddlersFunctions",
      "text": "(function(){\n\n  tw.macros.core.TrashCanIcon = () => {\n    let count = tw.tiddlers.trashed.length;\n    return tw.ui.button('{{$IconDelete}}', 'tiddler.show', '$TrashManager', 'trashCanIcon', `title=\"${count} trashed tiddlers\"`);\n  // return `<a id=\"trashCanIcon\" href=\"#$TrashManager\">🗑️ (${count})</a>`;\n  };\n  tw.macros.core.TrashEmptyButton = () => {\n    return tw.ui.button('Empty Trash', 'tiddlers.trashed.empty', null, 'trashButton');\n  };\n  tw.macros.core.TrashCanStatus = () => {\n    return `<span id=\"trashStatus\">${tw.tiddlers.trashed.length} tiddlers in the [trash can](#$TrashedTiddlers)!`;\n  };\n  tw.events.subscribe('tiddlers.trashed.empty', emptyTrash);\n  function emptyTrash() {\n    if (!confirm('Are you sure you want to permanently deleted your trashed tiddlers?')) return;\n    tw.tiddlers.trashed = [];\n    trashCanRefresh();\n    tw.run.save();\n  };\n  tw.macros.core.TrashCanContents = () => {\n    const list = tw.tiddlers.trashed.map(t => (`<li><a data-msg=\"tiddlers.trashed.preview\" data-param=\"${t.title}\">${t.title}</a> \n      <a title=\"Restore Tiddler\" data-msg=\"tiddler.trashed.restore\" data-param=\"${t.title}\">🚮</a></li>`)).join('\\n');\n    return `<ul id=\"trashContents\">${list}</ul>`;\n  };\n  tw.events.subscribe('tiddlers.trashed.preview', trashPreview);\n  function trashPreview(title) {\n    let tiddler = tw.tiddlers.trashed.find(t => t.title === title);\n    tw.run.previewTiddler(tiddler, tw.templates.TiddlerTrashed);\n  };\n\n  tw.events.subscribe('tiddler.trashed.destroy', removeTiddlerFromTrash);\n  function removeTiddlerFromTrash(title) {\n    if (!confirm('Are you sure you want to permanently delete your trashed tiddler?')) return;\n    let tiddlerIndex = tw.tiddlers.trashed.findIndex(t => t.title === title);\n    tw.tiddlers.trashed.splice(tiddlerIndex, 1);\n    trashCanRefresh();\n    tw.core.dom.preview.close();\n    tw.run.save();\n  };\n\n  tw.events.subscribe('tiddler.deleted', trashCanRefresh);\n  tw.events.subscribe('trash.refresh', trashCanRefresh);\n  function trashCanRefresh() {\n    if (tw.core.dom.$('trashContents')) tw.core.dom.$('trashContents').outerHTML = tw.lib.markdown(tw.macros.core.TrashCanContents());\n    if (tw.core.dom.$('trashCanIcon')) tw.core.dom.$('trashCanIcon').innerHTML = tw.macros.core.TrashCanIcon();\n    if (tw.core.dom.$('trashStatus')) tw.core.dom.$('trashStatus').outerHTML = tw.lib.markdown(tw.macros.core.TrashCanStatus());\n    tw.run.rerenderTiddler('$TrashedTiddlers');\n  };\n\n  tw.events.subscribe('tiddler.trashed.restore', restoreTiddlerFromTrash);\n  function restoreTiddlerFromTrash(title) {\n    if (!confirm('Are you sure you want to restore your trashed tiddler? This may overwrite an existing tiddler!')) return;\n    let tiddler = tw.tiddlers.trashed.find(t => t.title === title);\n    tw.run.addTiddler(tiddler);\n    tw.run.reload();\n    // So styles, search list etc update\n    let tiddlerIndex = tw.tiddlers.trashed.findIndex(t => t.title === title);\n    tw.tiddlers.trashed.splice(tiddlerIndex, 1);\n    trashCanRefresh();\n    tw.run.save();\n  };\n})();\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4881787Z",
      "updated": "2024-11-08T11:29:42.6778529Z"
    },
    {
      "title": "$TrashManager",
      "text": "<<TrashCanStatus>>\n<<TrashEmptyButton>>\n<<TrashCanContents>>",
      "tags": [],
      "type": "x-twikki",
      "created": "2024-11-08T10:20:43.4891792Z",
      "updated": "2024-09-16T21:35:11.0000000Z"
    },
    {
      "title": "$WorkspaceWidgets",
      "text": "tw.macros.core.WorkspaceSelect = () => {\n  let workspace = tw.storage.get('workspace');\n  return `<select id=\"workspace-select\" onchange=\"tw.events.send('workspace.load.prompt', this.value);\">\n    <option value=\"\"> - new workspace -</option>\n    ${tw.storage.get('workspaces').map(n => `<option value=\"${n}\"${n === workspace ? ' selected' : ''}>${n}</option>`).join('\\n')}\n  </select>`;\n};\ntw.macros.core.WorkspaceCreate = () => {\n  return tw.ui.button('Create Workspace', 'workspace.create.prompt');\n};\nif (!tw.tmp.workspaceEvents) {\n  tw.tmp.workspaceEvents = 1;\n  tw.events.subscribe('workspace.load.prompt', (workspace) => {\n    if (!workspace) workspace = tw.events.send('workspace.create.prompt')[0];\n    if (!workspace) return;\n    tw.events.send('workspace.load', workspace);\n  }, 'WorkspaceWidgets');\n  tw.events.subscribe('workspace.create.prompt', () => {\n    let workspace = prompt('Enter name for new workspace:');\n    if (!workspace) return;\n    if (confirm('Would you like to clone this workspace?'))\n      tw.events.send('workspace.clone', workspace);\n    else\n      tw.events.send('workspace.create', workspace);\n    tw.core.dom.$('workspace-select').innerHTML = tw.macros.core.WorkspaceSelect();\n    // tw.events.subscribe('tiddler.refresh', '$Workspaces'); // TODO: Dynamically get currentTiddler above?\n    return workspace;\n  }, 'WorkspaceWidgets');\n}\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4831799Z",
      "updated": "2024-11-08T11:33:06.8393930Z"
    },
    {
      "title": "Backup",
      "text": "Backup will push all data (including trashed tiddlers and the visible state) to a remote.\n* <<backup.backupButton>>: Backup data\n* <<backup.restoreButton>>: Restore all data (!will overwrite everything)\n\nNote: In case you mess up we routinely make a local backup - press F12 and check under Application - Local Data",
      "tags": [],
      "type": "x-twikki",
      "created": "2024-11-08T10:20:43.4901789Z",
      "updated": "2024-10-16T19:33:47.7878625Z"
    },
    {
      "title": "HighlightPlugin",
      "text": "// https://www.jsdelivr.com/package/npm/highlight.js\n// https://cdnjs.com/libraries/highlight.js\n\n(function(){\n\n  tw.events.subscribe('ui.loaded', () => {\n    tw.core.dom.addStyleSheet('highlight-light', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/atom-one-light.min.css');\n    tw.core.dom.addStyleSheet('highlight-dark', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/atom-one-dark.min.css');\n    tw.core.dom.addScript('highlight-core', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/highlight.min.js');\n    tw.events.subscribe('script.loaded', (name) => {\n      if (name === 'highlight-core') {\n        tw.core.dom.addScript('highlight-lang-javascript', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/javascript.min.js');\n        tw.core.dom.addScript('highlight-lang-css', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/css.min.js');\n        tw.core.dom.addScript('highlight-lang-xml', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/xml.min.js');\n        tw.core.dom.addScript('highlight-lang-json', 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/languages/json.min.js');\n        return;\n      }\n      if (name !== 'highlight-lang-json') return;\n      tw.lib.highlight = window.hljs;\n      tw.events.send('highlight.loaded');\n    }, 'HighlightPlugin');\n  }, 'HighlightPlugin');\n  tw.events.subscribe('tiddler.rendered', ({tiddler, newElement}) => {\n    newElement.querySelectorAll('pre code').forEach(el => (tw.lib.highlight?.highlightElement(el, {language: languageFromTiddlerType(tiddler.type)})));\n  }, 'HighlightPlugin');\n\n  function languageFromTiddlerType(type) {\n    switch (type) {\n      case 'script/js':\n        return 'javascript';\n      case 'css':\n        return 'css';\n      case 'html/template':\n        return 'xml';\n      case 'json':\n        return 'json';\n      default:\n        return '';\n    }\n  }\n})();\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4918023Z",
      "updated": "2024-11-08T11:47:01.6995242Z"
    },
    {
      "title": "SelectorWidget",
      "text": "/**\n  * .SYNOPSIS\n  * Show a selection of values\n  *\n  * .DESCRIPTION\n  * Provide a dynamic data-driven HTML <select> box with handler\n  *\n  * .EXAMPLE\n  * Show a selection of 3 fixed colors:\n  * <<selector red,green, blue>>\n  *\n  * .EXAMPLE\n  * Show a selection of colors from a datalist tiddler:\n  * <<selector {tw.run.getTiddlerTextList('ColorSelection')}>>\n  *\n  * .EXAMPLE\n  * Show a selection of 3 keyval pairs:\n  * <<selector #f00:red #0f0:green #00f:blue>>\n  *\n  * TODO: Create a widget which updates the text/field of a tiddler\n  *         This would be great in the $Theme tiddler to directly select a theme\n  *         <<selector {tw.theme.getThemeNames()}>>\n  */\ntw.macros.core.selector = (values) => {\n  if (typeof values === 'string') values = values.split(/,\\s?/);\n  if (typeof values === 'object' && !Array.isArray(values)) values = Object.keys(values).map(key => ({key, value: values[key]}));\n  if (!Array.isArray(values)) throw new Error('No array passed!');\n  return `<select>\n  ${values.map(v => '<option value=\"' + (v?.key || v) + '\">' + (v?.value || v) + '</option>').join('')}\n  </select>`;\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-11-08T10:20:43.4938702Z",
      "updated": "2024-10-23T07:09:40.7299054Z"
    },
    {
      "title": "Synchronization",
      "text": "Synchronization replicates local changes to a remote defined in [[$GeneralSettings]]:\n* <<synch.test>>: Simulate a Synch\n* <<synch.full>>: Run full synch (pull+push)\n* <<synch.push>>: Push changes to remote\n* <<synch.pull>>: Pull changes from remote",
      "tags": [],
      "type": "x-twikki",
      "created": "2024-11-08T10:20:43.4947305Z",
      "updated": "2024-10-12T18:29:20.6997473Z"
    }
  ]
}
